import datetimeimport globimport osimport pandas as pdfrom clearCSV import clearCSVdef calculate_consumption():    # Leggere i file CSV e calcolare il consumo energetico    directory_dataset_path = 'Dataset/'    csv_files = glob.glob(os.path.join(directory_dataset_path, '*.csv'))    dfs = clearCSV(csv_files)    consumption_dict = {}    for dataset in dfs:        consumption_dict[dataset] = calculate_consumption_in_time(dfs[dataset], dataset)    final_merged_dfs = {'H': None, 'D': None, 'M': None, 'Y': None}    for dataset_name, dataset_dict in consumption_dict.items():        for time_interval, df in dataset_dict.items():            # Selezionare solo le colonne di interesse e rinominare la colonna dei consumi            df = df[['Date', f'{time_interval}_kilowatt_cons']].copy()            df.rename(columns={f'{time_interval}_kilowatt_cons': f'{time_interval}_kilowatt_cons_{dataset_name}'},                      inplace=True)            # Rimuovere le righe con valori NaN dopo aver selezionato le colonne di interesse            df.dropna(inplace=True)            # Se il dataframe per questo intervallo temporale non esiste ancora, inizializzarlo            if final_merged_dfs[time_interval] is None:                final_merged_dfs[time_interval] = df            else:                # Eseguire il merge mantenendo l'ordine in base alla colonna 'Date' del dataframe esistente                final_merged_dfs[time_interval] = pd.merge(final_merged_dfs[time_interval], df, on='Date', how='outer')    # Dopo aver completato tutti i merge, rimuovere eventuali NaN risultanti dal merge    for time_interval, df in final_merged_dfs.items():        df.dropna(inplace=True)        folder_path = f'dataset_result/kilowatt_consumption/final_merged/'        os.makedirs(folder_path, exist_ok=True)        df.to_csv(os.path.join(folder_path, f'final_merged_{time_interval}.csv'), index=False)        # TO DO: Calcolare il timeslot, calcolare la colonna del valore del consumo degli uffici    return consumption_dictdef calculate_consumption_in_time(consumption_per_date, name):    # Initialize a dictionary to hold the different consumption DataFrames    consumption_diffs = {}    # Calculate differences and format date ranges for hourly, daily, monthly, yearly    for freq in ['H', 'D', 'M', 'Y']:        if freq == 'H':            consumption_per_hour = calculate_consumption_in_time_slot(consumption_per_date)            folder_path = f'dataset_result/consumption_timeslot/'            os.makedirs(folder_path, exist_ok=True)            consumption_per_hour.to_csv(os.path.join(folder_path, f'{name}_{freq.lower()}_consumption_timeslot.csv'),                                        index=True)            # isSmartWorkingDay(consumption_per_hour)        diff = calculate_consumption_h_d_m_y(consumption_per_date, freq)        folder_path = f'dataset_result/kilowatt_consumption/{freq}/'        os.makedirs(folder_path, exist_ok=True)        consumption_diffs[freq] = diff        diff.to_csv(os.path.join(folder_path, f'{name}_{freq.lower()}_consumption.csv'), index=False)    return consumption_diffsdef calculate_consumption_h_d_m_y(dataset, freq):    dataset['Date'] = pd.to_datetime(dataset['Date'])    # Calcolo la differenza di consumo per ogni riga    dataset[f'{freq}_kilowatt_cons'] = dataset['Kilowatt'].diff()    # Aggreo i consumi per la frequenza specificata (H,D,M,Y) con right sto prendendo l'ultimo valore compreso degli    # orario quindi non 00:55 ma 01:00    consumption = dataset.resample(freq, on='Date', closed='right')[f'{freq}_kilowatt_cons'].sum()    consumption = consumption.reset_index()    consumption[f'{freq}_kilowatt_cons'] = consumption[f'{freq}_kilowatt_cons']    # Sposta indietro l'etichetta di tempo di un'unitÃ  della frequenza selezionata per allineare l'etichetta con    # l'inizio dell'intervallo    # if freq == 'H':    #     consumption['Date'] = consumption['Date'] - pd.Timedelta(hours=1)    # elif freq == 'D':    #     consumption['Date'] = consumption['Date'] - pd.Timedelta(days=1)    consumption['Date'] = consumption['Date'].apply(lambda x: format_date_range(x, freq))    consumption.insert(0, 'ID', range(len(consumption)))    return consumption# funzione principale che serve a calcolare i consumi per fascia orariadef calculate_consumption_in_time_slot(dataset):    dataset_hour = dataset    dataset_hour = dataset_hour.reset_index()    dataset_hour['Date'] = pd.to_datetime(dataset_hour['Date'])    # Ordinamento dei dati per data e ora    dataset_hour.sort_values(by='Date', inplace=True)    # Modifico la data per le righe che hanno un timestamp a mezzanotte, spostandole al giorno precedente.    # dataset_hour['Date'] = dataset_hour['Date'].apply(    #     lambda dt: dt - pd.Timedelta(minutes=1) if dt.time() == datetime.time(0, 0) else dt)    # raggruppo i dati in base alla data aggiustata.    consumption_per_hour = dataset_hour.groupby(dataset_hour['Date'].dt.date).apply(calculate_diff)    # consumption_per_hour = dataset_hour.groupby(dataset_hour['Date'].dt.date).apply(calculate_diff)    consumption_per_hour = consumption_per_hour.reset_index()    consumption_per_hour = consumption_per_hour.round(2)    # Creo colonna dove setto i giorni della settimana da 0 (lunedi) a 6(domenica)    consumption_per_hour['day_of_the_week'] = pd.to_datetime(consumption_per_hour['Date']).apply(        lambda x: x.weekday())    if 'level_1' in consumption_per_hour.columns:        consumption_per_hour.rename(columns={'level_1': 'ID'}, inplace=True)    return consumption_per_hour# Calcolo delle differenze di consumo per ogni fascia orariadef calculate_diff(group):    group = group.set_index('Date')    morning_start, morning_end = get_start_end_values(group, 0, 9, 00)    afternoon_start, afternoon_end = get_start_end_values(group, 9, 18, 00)    night_start, night_end = get_start_end_values(group, 18, 0, 00)    return pd.Series({        '00:00-09:00': morning_end - morning_start if morning_end is not None and morning_start is not None else None,        '09:00-18:00': afternoon_end - afternoon_start if afternoon_end is not None and afternoon_start is not None else None,        '18:00-00:00': night_end - night_start if night_end is not None and night_start is not None else None    })# Funzione per otter l'ultimo e il primo valore di kilowatt in una fascia orariadef get_start_end_values(group, start_hour, end_hour, end_minute=00):    # Filtro per la fascia oraria    filtered_group = group.between_time(f'{start_hour}:00', f'{end_hour}:{end_minute}')    # ultimo valore della fascia oraria    end_value = filtered_group['Kilowatt'].iloc[-1] if not filtered_group.empty else None    # primo valore della fascia oraria    start_value = filtered_group['Kilowatt'].iloc[0] if not filtered_group.empty else None    return start_value, end_value# Format datedef format_date_range(start, frequ):    if frequ == 'H':        end = start + pd.Timedelta(hours=1)        return start.strftime('%Y-%m-%d %H:00 -> ') + end.strftime('%H:00')    elif frequ == 'D':        return start.strftime('%Y-%m-%d')    elif frequ == 'M':        return start.strftime('%Y-%m')    elif frequ == 'Y':        return start.strftime('%Y')